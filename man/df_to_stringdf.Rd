% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/df_to_string.R
\name{df_to_stringdf}
\alias{df_to_stringdf}
\alias{df_to_markdown}
\alias{stringdf_to_df}
\alias{markdown_to_df}
\title{String Data Frames}
\usage{
df_to_stringdf(df, rownames = FALSE)

df_to_markdown(df)

stringdf_to_df(str_df, data.frame = FALSE)

markdown_to_df(md_df, trim_ws = TRUE, na = "NA", data.frame = FALSE)
}
\arguments{
\item{df}{A data.frame or data_frame to convert to text}

\item{str_df}{A string dataframe output by df_to_stringdf(...)}

\item{data.frame}{Return rebuilt data.frames instead of tibbles}

\item{md_df}{A markdown dataframe output by df_to_markdown(...)}
}
\value{
\code{df_to_stringdf() and df_to_markdown()} both return character string representing the data.frame

\code{stringdf_to_df() and markdown_to_df()} both return rebuilt data_frame/data.frame objects closely approximating the originals
}
\description{
This package provides 2 methods to convert a data.frame/tibble to a single character string and back to its original form (largely intact).  Conversion is either to an unformatted string or a markdown table.

The aim is to provide a method to convert data.frames that are embedded inside other data.frames (as list fields) to a form that enables them to be saved to a single csv file or an external database table (rather than requiring a relational multi-table approach), but so the resulting embedded string_dataframes can be easily returned to data.frame format when returned to R.  This might suit you if your embedded dataframes are relatively small, static, or if you don't need to query them on a row-by-row basis.
}
\examples{
require(stringDataFrame)
require(tidyverse)

set.seed(1)
df_orig = data_frame(`item date` = seq(as.Date('2018-01-01'), as.Date('2018-01-05'), 1),
                     id = 1:5, grp = c('A','A','B','B','B'),
                     val = c(NA, rlnorm(4, sd=10)), condition = c(T,F,F,T,T),
                     txt = c(NA, '', 'The quick brown fox', 'jumped over the', 'quick | brown dog.'))
print(df_orig)


## conversion to string_dataframe and back

df_string = df_to_stringdf(df_orig)
cat(df_string)

df_from_string = stringdf_to_df(df_string)
print(df_from_string)


## conversion to markdown table and back

df_markdown = df_to_markdown(df_orig)
cat(df_markdown)

df_from_markdown = markdown_to_df(df_markdown)
print(df_from_markdown)


## Handling list-embedded data.frames

beavers = data_frame(beaver = c('beaver1','beaver2'), data = list(head(beaver1), head(beaver2)))
print(beavers)

beavers_mkd = beavers \%>\% mutate(data = map_chr(data, df_to_markdown))
print(beavers_mkd)

beavers_mkd$data[1] \%>\% cat

beavers_mkd \%>\% pmap_df(~ markdown_to_df(.y) \%>\% mutate(beaver = .x))


## To compare before/after you can use `all_equal` function (`convert=TRUE` recommended) on data.frames with any factors removed. Objects won't always match up exactly (e.g. numbers with long decimals may be truncated to ~7 places), but loss is either very small, or zero as in this example:

df_orig = ggplot2::diamonds \%>\% mutate_if(is.factor, funs(as.character(.)))
df_string = df_to_stringdf(df_orig)
df_from_string = stringdf_to_df(df_string)
all_equal(df_orig, df_from_string, convert=TRUE)
}
